<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>bot.signal_generator API documentation</title>
<meta name="description" content="Project_Name: magic_bot, File_name: signal_generator.py
Author: kalabharath, Email: kalabharath@gmail.com" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bot.signal_generator</code></h1>
</header>
<section id="section-intro">
<p>Project_Name: magic_bot, File_name: signal_generator.py
Author: kalabharath, Email: kalabharath@gmail.com</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Project_Name: magic_bot, File_name: signal_generator.py
Author: kalabharath, Email: kalabharath@gmail.com
&#34;&#34;&#34;
from sklearn.preprocessing import minmax_scale
import datetime
import os
import time
import argparse
import cufflinks as cf
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import plotly.io as pio
import plotly.offline as plyo
import tensorflow as tf
import yfinance as yf
from keras_preprocessing import image
from prettytable import PrettyTable

from tqdm import tqdm

from bot.minimal_radar import ComplexRadar

matplotlib.use(&#39;TkAgg&#39;)


class AutoPlotNsave():
    &#34;&#34;&#34;
    Supervised selection of 3-month period stock with stock reaching the lowest before a 10% intra-day bump
    and continues exponential climbing.
    1. Displays the gradual drop of stock prices in a three month period where the the normalized &#39;RSI&#39; and
    &#39;ATR&#39; or &#39;VWAP&#34; reaches zero.
    2. Draw the support and resistance lines.
    3. Draw the entry and exit prices at 1:3 risk to reward profile.
    4. Save the profile if steps 1-3 above were true.
    &#34;&#34;&#34;

    def __init__(self, time_series, ticker, rsi_threshold, downside_threshold, tf_model, time_period):
        &#34;&#34;&#34;[summary]

        Args:
            time_series (dataframe):
            ticker ([type]): [description]
            rsi_threshold ([type]): [description]
            downside_threshold ([type]): [description]
            tf_model ([type]): [description]
        &#34;&#34;&#34;
        self.time_series = time_series
        self.ticker = ticker
        self.rsi_threshold = rsi_threshold
        self.down_threshold = downside_threshold
        self.tf_model = tf_model
        self.time_period = time_period

    @staticmethod
    def compute_rsi(df, periods):
        &#34;&#34;&#34;Computes Relative strength index for a given

        Args:
            df (data frame): contains time series
            periods (int): rolling window period, typically 14 days

        Returns:
            df (data frame): the returned dataframe now contains computed &#39;RSI&#39; column
        &#34;&#34;&#34;

        df[&#39;Up&#39;] = df[&#39;Close&#39;].diff().apply(lambda x: x if x &gt; 0 else 0)
        df[&#39;Down&#39;] = df[&#39;Close&#39;].diff().apply(lambda x: -x if x &lt; 0 else 0)
        df[&#39;UpAvg&#39;] = df[&#39;Up&#39;].rolling(window=periods).mean()
        df[&#39;DownAvg&#39;] = df[&#39;Down&#39;].rolling(window=periods).mean()
        df[&#39;RSI&#39;] = 100 - (100 / (1 + df[&#39;UpAvg&#39;] / df[&#39;DownAvg&#39;]))
        return df

    @staticmethod
    def numba_interweave(arr1, arr2):
        &#34;&#34;&#34;
        interweaves one array with another, eg [1,2,3] and [A, B, C] = [1, A, 2, B, 3, C]
        :param arr1:
        :param arr2:
        :return: interweave array
        &#34;&#34;&#34;
        res = np.empty(arr1.size + arr2.size, dtype=arr1.dtype)
        for idx, (item1, item2) in enumerate(zip(arr1, arr2)):
            res[idx * 2] = item1
            res[idx * 2 + 1] = item2
        return res

    @staticmethod
    def reduce_array(arr, time_period):
        &#34;&#34;&#34;
        Dimensonality or data reduction by averaging over a specified window of three.
        :param arr:
        :return:
        &#34;&#34;&#34;
        factor = int(time_period / 3.0)
        if len(arr) % (3 * factor) == 0:
            t = np.mean(arr.reshape(-1, (3 * factor)), axis=1)
        else:
            t = np.nanmean(
                np.pad(arr.astype(float), (0, (3 * factor) - arr.size % (3 * factor)), mode=&#39;constant&#39;,
                       constant_values=np.NaN).reshape(-1, 3 * factor), axis=1)

        return t

    def cufflinks_display(self):
        &#34;&#34;&#34;[summary]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;

        data = self.compute_rsi(self.time_series, periods=14)
        try:
            start = self.time_series.index[len(self.time_series.index) - (67 * int(self.time_period / 3.0))]
            stop = self.time_series.index[-1]
            evaluation_date = self.time_series.index[- 1]
        except Exception as e:
            print(e)
            return [&#39;Error&#39;, self.ticker, &#39;Could not get data&#39;]
        time_format = &#39;%d%b%y&#39;
        quant_title = self.ticker + &#34;_&#34; + start.strftime(time_format) + &#34;_&#34; + evaluation_date.strftime(time_format)

        data = data.loc[start:stop]
        data[&#39;VWAP&#39;] = (data[&#39;Volume&#39;] * (data[&#39;High&#39;] +
                                          data[&#39;Close&#39;]) / 2).cumsum() / data[&#39;Volume&#39;].cumsum()

        # is today&#39;s close price less than vwap ?
        vwap_percent = (data[&#39;Close&#39;].loc[stop] / data[&#39;VWAP&#39;].loc[stop] - 1) * 100

        todays_rsi = data[&#39;RSI&#39;].loc[stop]

        rsi_within_threshold = False

        for t_rsi in range(5, self.rsi_threshold):

            if todays_rsi &lt;= t_rsi:
                # print(&#34;Rsi is within threshold of &#34;, t_rsi, &#34;/&#34;, todays_rsi)
                rsi_within_threshold = True
                break

        if not rsi_within_threshold:
            # print(&#34;Rsi is Not within threshold of 5-&#34;, self.rsi_threshold, &#34;:&#34;, todays_rsi)
            return [&#39;Skip&#39;, self.ticker, vwap_percent, todays_rsi]

        # if the downtrend is not within a specified limit, continue

        daily_percent_change = (data[&#39;Close&#39;].loc[evaluation_date] / data[&#39;Close&#39;] - 1) * 100
        downside_yield_date = daily_percent_change.idxmin()
        downside = round(daily_percent_change.min(), 2)

        if not downside &lt;= self.down_threshold:
            return [&#39;Skip&#39;, self.ticker, downside, vwap_percent, todays_rsi]
        # plot candle chart
        quotes = data[[&#39;Open&#39;, &#39;High&#39;, &#39;Low&#39;, &#39;Close&#39;, &#39;Volume&#39;]]
        qf = cf.QuantFig(quotes, title=quant_title, name=&#39;1D Historical&#39;, up_color=&#39;green&#39;, down_color=&#39;red&#39;)
        qf.add_rsi(periods=14, showbands=True)
        qf.add_bollinger_bands()
        qf.add_support(date=evaluation_date.strftime(time_format))
        qf.add_volume(colorchange=True)
        qf.add_trendline(date0=downside_yield_date.strftime(time_format), date1=evaluation_date.strftime(time_format),
                         text=str(downside))  # add trend line
        # plyo.iplot(qf.iplot(asFigure=True))

        # make a radar plot
        vwap = data[&#39;VWAP&#39;].to_numpy()
        rsi = data[&#39;RSI&#39;].to_numpy()
        s_rsi = minmax_scale(rsi, feature_range=(0, 1))
        s_vwap = minmax_scale(vwap, feature_range=(0, 1))

        # reduce the array dimensionality/complexity
        s_vwap = self.reduce_array(arr=s_vwap, time_period=self.time_period)
        s_rsi = self.reduce_array(arr=s_rsi, time_period=self.time_period)
        variables = self.numba_interweave(s_vwap, s_rsi)  # interweave vwap and rsi
        data = np.array(variables)
        ranges = []
        for _ in range(0, len(variables)):
            ranges.append([0, 1])
        fig1 = plt.figure(figsize=(3, 3), dpi=150)
        radar = ComplexRadar(fig1, variables, ranges)
        radar.plot(data)
        radar.fill(data, alpha=0.2)

        plt.draw()
        plt.savefig(quant_title + &#34;_radar.png&#34;)
        # plt.show(block=False)
        time.sleep(0.10)
        fig1.clear()
        plt.close(fig1)

        pio.write_image(qf.iplot(asFigure=True),
                        file=quant_title + &#34;.png&#34;, width=2560, height=1707)
        qf.add_shapes()

        img = image.load_img(quant_title + &#34;_radar.png&#34;,
                             target_size=(300, 300))
        x = image.img_to_array(img)
        x = np.expand_dims(x, axis=0)
        images = np.vstack([x])
        classes = self.tf_model.predict(images, batch_size=10)

        if int(classes[0]) == 0:  # decoy
            # mv_file = &#34;mv &#34; + quant_title + &#34;* decoy/&#34;
            # os.system(mv_file)
            return [&#39;Decoy&#39;, self.ticker, downside, vwap_percent, todays_rsi]

        elif int(classes[0]) == 1:  # target
            # mv_file = &#34;mv &#34; + quant_title + &#34;* target/&#34;
            # os.system(mv_file)
            return [&#39;Target&#39;, self.ticker, downside, vwap_percent, todays_rsi]

        else:
            print(&#34;*******: Something is seriously wrong with the logic&#34;)

        return [&#39;Skip&#39;, &#39;Error&#39;]


if __name__ == &#39;__main__&#39;:
    &#34;&#34;&#34;
    Summary: Parse through tickers and generate buy or a sell signal

        Returns:
            Table/DataFrame : specifying targets and decoys with the following datapoints
            +-------------------+----------+----------+---------------------+--------------------+
            | AI Classification |  Ticker  | Downside |     vwap_percent    |     todays_rsi     |
            +-------------------+----------+----------+---------------------+--------------------+
            |       Target      |   JSL    |  -44.37  | -30.503006540229382 | 18.550959195978393 |
            |       Decoy       |  AMBER   |  -40.65  | -24.915387442309257 | 23.092182587967315 |
            +-------------------+----------+----------+---------------------+--------------------+

    &#34;&#34;&#34;

    parser = argparse.ArgumentParser(description=&#39;Magic formula for NASDAQ and NYSE&#39;)

    parser.add_argument(&#39;--time_period&#39;, default=6, type=int,
                        help=&#39;Supply either 3 Months or 6 Months timeframe&#39;)
    parser.add_argument(&#39;--downside_threshold&#39;, default=-50, type=int, help=&#39;Minimum downside threshold&#39;)
    parser.add_argument(&#39;--rsi_threshold&#39;, default=40, type=int, help=&#39;Minimum rsi threshold&#39;)
    args = parser.parse_args()

    current_month = str(datetime.datetime.now().month)
    current_year = str(datetime.datetime.now().year)

    pandas_fii_investments_file = &#34;./data/&#34; + current_month + &#34;_&#34; + \
                                  current_year + &#34;_data/&#34; + current_month + &#39;_fiis_&#39; + current_year + &#39;.pkl&#39;
    nse_listed_mnc = [&#39;LINDEINDIA&#39;, &#39;PFIZER&#39;, &#39;ABBOTINDIA&#39;, &#39;ASTRAZEN&#39;, &#39;RAJESHEXPO&#39;, &#39;GLAXO&#39;, &#39;MPHASIS&#39;,
                      &#39;SANOFI&#39;, &#39;COLPAL&#39;, &#39;CASTROLIND&#39;, &#39;SIEMENS&#39;, &#39;OFSS&#39;, &#39;NESTLEIND&#39;, &#39;BRITANNIA&#39;, &#39;HONAUT&#39;,
                      &#39;ABB&#39;, &#39;BOSCHLTD&#39;, &#39;3MINDIA&#39;, &#39;AKZOINDIA&#39;, &#39;ASAHIINDIA&#39;,
                      &#39;BERGEPAINT&#39;, &#39;CIGNITITEC&#39;, &#39;CLNINDIA&#39;, &#39;DENORA&#39;, &#39;CUMMINSIND&#39;, &#39;DICIND&#39;,
                      &#39;DLINKINDIA&#39;, &#39;ESABINDIA&#39;, &#39;FMGOETZE&#39;, &#39;FOSECOIND&#39;,
                      &#39;GABRIEL&#39;, &#39;GILLETTE&#39;, &#39;GOODYEAR&#39;, &#39;GPPL&#39;, &#39;HEIDELBERG&#39;, &#39;HONDAPOWER&#39;,
                      &#39;INDNIPPON&#39;, &#39;INDOTECH&#39;, &#39;INGERRAND&#39;, &#39;ITDCEM&#39;, &#39;KENNAMET&#39;, &#39;KOKUYOCMLN&#39;,
                      &#39;KSB&#39;, &#39;LUMAXIND&#39;, &#39;MOTHERSUMI&#39;, &#39;MPHASIS&#39;, &#39;NOVARTIND&#39;,
                      &#39;PAGEIND&#39;, &#39;SHREYAS&#39;, &#39;SKFINDIA&#39;,
                      &#39;SMLISUZU&#39;, &#39;TIMKEN&#39;, &#39;VESUVIUS&#39;, &#39;HDFCAMC&#39;, &#39;VEDL&#39;]

    tf_file = &#39;./tf_model/target_pattern2022GC.h5&#39;
    fii_data = pd.read_pickle(pandas_fii_investments_file)
    print(fii_data)
    model = tf.keras.models.load_model(tf_file)
    today_1 = datetime.date.today()
    exclude_sectors = [&#39;Banks&#39;, &#39;Bank&#39;, &#39;Finance&#39;, &#39;Insurance&#39;]  # these sectors have no tangible assets

    for exclude_sector in exclude_sectors:
        fii_data.drop(fii_data.loc[fii_data[&#39;sectors&#39;] == exclude_sector].index, inplace=True)

    ticker_symbols = fii_data[&#39;ticker&#39;].to_list()
    ticker_symbols = ticker_symbols + nse_listed_mnc
    ticker_symbols = sorted(ticker_symbols)  # sort alphabetically!
    print(ticker_symbols, len(ticker_symbols))
    data_return = []

    for i in tqdm(range(len(ticker_symbols))):
        company = ticker_symbols[i]
        if company.isdigit():
            continue
        start_date = today_1 - datetime.timedelta(days=((args.time_period) + 1) * 30)
        t = yf.Ticker(company + &#39;.NS&#39;)
        time_series_data = t.history(start=start_date, interval=&#34;1d&#34;)
        plot = AutoPlotNsave(time_series=time_series_data, ticker=company, rsi_threshold=args.rsi_threshold,
                             downside_threshold=args.downside_threshold, tf_model=model, time_period=args.time_period)
        data_return.append(plot.cufflinks_display())

    # plot_summary &amp; display targets
    targets, decoys = [], []
    for hit in data_return:
        if len(hit) &gt; 0:
            if hit[0] == &#39;Target&#39;:
                targets.append(hit)
            elif hit[0] == &#39;Decoy&#39;:
                decoys.append(hit)
            elif hit[0] == &#39;Error&#39;:
                print (&#34;Coundn&#39;t get data for this ticker: &#34;, hit[1])
    x = PrettyTable()
    c_columns = [&#39;AI Classification&#39;, &#34;Ticker&#34;, &#34;Downside&#34;, &#34;vwap_percent&#34;, &#34;todays_rsi&#34;]
    x.field_names = c_columns
    x.add_rows(targets)
    x.add_rows(decoys)
    print(x)  # save and dump every day dataframes for further analytic analysis # load daily hits as a pandas df

    df_path = &#39;magic_formula_daily.pkl&#39;
    # check if the last modifed date is today, if so skip.
    from summary import generate_daily_summary

    generate_daily_summary(output_file_preix=&#39;summary_&#39; + str(args.time_period) + str(today_1))

    if os.path.isfile(df_path):
        stat_result = os.stat(df_path)
        modified = datetime.datetime.fromtimestamp(stat_result.st_mtime)
        last_modified = modified.date()

        if last_modified == today_1:
            print(&#34;Looks like this is the second run of today&#34;)
        else:
            if os.path.isfile(df_path):
                backup = &#34;cp &#34; + df_path + &#34; &#34; + df_path + str(today_1)
                os.system(backup)
                df_file = pd.read_pickle(df_path)
                tdf_file = pd.DataFrame(decoys + targets, columns=c_columns)
                tdf_file[&#39;dates&#39;] = pd.Timestamp(today_1)
                df_file = df_file.append(tdf_file)
                print(df_file)
                df_file.to_pickle(df_path)
    else:
        df_file = pd.DataFrame(decoys + targets, columns=c_columns)
        df_file[&#39;dates&#39;] = pd.Timestamp(today_1)
        df_file.to_pickle(df_path)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="bot.signal_generator.AutoPlotNsave"><code class="flex name class">
<span>class <span class="ident">AutoPlotNsave</span></span>
<span>(</span><span>time_series, ticker, rsi_threshold, downside_threshold, tf_model, time_period)</span>
</code></dt>
<dd>
<div class="desc"><p>Supervised selection of 3-month period stock with stock reaching the lowest before a 10% intra-day bump
and continues exponential climbing.
1. Displays the gradual drop of stock prices in a three month period where the the normalized 'RSI' and
'ATR' or 'VWAP" reaches zero.
2. Draw the support and resistance lines.
3. Draw the entry and exit prices at 1:3 risk to reward profile.
4. Save the profile if steps 1-3 above were true.</p>
<p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt>time_series (dataframe):</dt>
<dt><strong><code>ticker</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>rsi_threshold</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>downside_threshold</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>tf_model</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AutoPlotNsave():
    &#34;&#34;&#34;
    Supervised selection of 3-month period stock with stock reaching the lowest before a 10% intra-day bump
    and continues exponential climbing.
    1. Displays the gradual drop of stock prices in a three month period where the the normalized &#39;RSI&#39; and
    &#39;ATR&#39; or &#39;VWAP&#34; reaches zero.
    2. Draw the support and resistance lines.
    3. Draw the entry and exit prices at 1:3 risk to reward profile.
    4. Save the profile if steps 1-3 above were true.
    &#34;&#34;&#34;

    def __init__(self, time_series, ticker, rsi_threshold, downside_threshold, tf_model, time_period):
        &#34;&#34;&#34;[summary]

        Args:
            time_series (dataframe):
            ticker ([type]): [description]
            rsi_threshold ([type]): [description]
            downside_threshold ([type]): [description]
            tf_model ([type]): [description]
        &#34;&#34;&#34;
        self.time_series = time_series
        self.ticker = ticker
        self.rsi_threshold = rsi_threshold
        self.down_threshold = downside_threshold
        self.tf_model = tf_model
        self.time_period = time_period

    @staticmethod
    def compute_rsi(df, periods):
        &#34;&#34;&#34;Computes Relative strength index for a given

        Args:
            df (data frame): contains time series
            periods (int): rolling window period, typically 14 days

        Returns:
            df (data frame): the returned dataframe now contains computed &#39;RSI&#39; column
        &#34;&#34;&#34;

        df[&#39;Up&#39;] = df[&#39;Close&#39;].diff().apply(lambda x: x if x &gt; 0 else 0)
        df[&#39;Down&#39;] = df[&#39;Close&#39;].diff().apply(lambda x: -x if x &lt; 0 else 0)
        df[&#39;UpAvg&#39;] = df[&#39;Up&#39;].rolling(window=periods).mean()
        df[&#39;DownAvg&#39;] = df[&#39;Down&#39;].rolling(window=periods).mean()
        df[&#39;RSI&#39;] = 100 - (100 / (1 + df[&#39;UpAvg&#39;] / df[&#39;DownAvg&#39;]))
        return df

    @staticmethod
    def numba_interweave(arr1, arr2):
        &#34;&#34;&#34;
        interweaves one array with another, eg [1,2,3] and [A, B, C] = [1, A, 2, B, 3, C]
        :param arr1:
        :param arr2:
        :return: interweave array
        &#34;&#34;&#34;
        res = np.empty(arr1.size + arr2.size, dtype=arr1.dtype)
        for idx, (item1, item2) in enumerate(zip(arr1, arr2)):
            res[idx * 2] = item1
            res[idx * 2 + 1] = item2
        return res

    @staticmethod
    def reduce_array(arr, time_period):
        &#34;&#34;&#34;
        Dimensonality or data reduction by averaging over a specified window of three.
        :param arr:
        :return:
        &#34;&#34;&#34;
        factor = int(time_period / 3.0)
        if len(arr) % (3 * factor) == 0:
            t = np.mean(arr.reshape(-1, (3 * factor)), axis=1)
        else:
            t = np.nanmean(
                np.pad(arr.astype(float), (0, (3 * factor) - arr.size % (3 * factor)), mode=&#39;constant&#39;,
                       constant_values=np.NaN).reshape(-1, 3 * factor), axis=1)

        return t

    def cufflinks_display(self):
        &#34;&#34;&#34;[summary]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;

        data = self.compute_rsi(self.time_series, periods=14)
        try:
            start = self.time_series.index[len(self.time_series.index) - (67 * int(self.time_period / 3.0))]
            stop = self.time_series.index[-1]
            evaluation_date = self.time_series.index[- 1]
        except Exception as e:
            print(e)
            return [&#39;Error&#39;, self.ticker, &#39;Could not get data&#39;]
        time_format = &#39;%d%b%y&#39;
        quant_title = self.ticker + &#34;_&#34; + start.strftime(time_format) + &#34;_&#34; + evaluation_date.strftime(time_format)

        data = data.loc[start:stop]
        data[&#39;VWAP&#39;] = (data[&#39;Volume&#39;] * (data[&#39;High&#39;] +
                                          data[&#39;Close&#39;]) / 2).cumsum() / data[&#39;Volume&#39;].cumsum()

        # is today&#39;s close price less than vwap ?
        vwap_percent = (data[&#39;Close&#39;].loc[stop] / data[&#39;VWAP&#39;].loc[stop] - 1) * 100

        todays_rsi = data[&#39;RSI&#39;].loc[stop]

        rsi_within_threshold = False

        for t_rsi in range(5, self.rsi_threshold):

            if todays_rsi &lt;= t_rsi:
                # print(&#34;Rsi is within threshold of &#34;, t_rsi, &#34;/&#34;, todays_rsi)
                rsi_within_threshold = True
                break

        if not rsi_within_threshold:
            # print(&#34;Rsi is Not within threshold of 5-&#34;, self.rsi_threshold, &#34;:&#34;, todays_rsi)
            return [&#39;Skip&#39;, self.ticker, vwap_percent, todays_rsi]

        # if the downtrend is not within a specified limit, continue

        daily_percent_change = (data[&#39;Close&#39;].loc[evaluation_date] / data[&#39;Close&#39;] - 1) * 100
        downside_yield_date = daily_percent_change.idxmin()
        downside = round(daily_percent_change.min(), 2)

        if not downside &lt;= self.down_threshold:
            return [&#39;Skip&#39;, self.ticker, downside, vwap_percent, todays_rsi]
        # plot candle chart
        quotes = data[[&#39;Open&#39;, &#39;High&#39;, &#39;Low&#39;, &#39;Close&#39;, &#39;Volume&#39;]]
        qf = cf.QuantFig(quotes, title=quant_title, name=&#39;1D Historical&#39;, up_color=&#39;green&#39;, down_color=&#39;red&#39;)
        qf.add_rsi(periods=14, showbands=True)
        qf.add_bollinger_bands()
        qf.add_support(date=evaluation_date.strftime(time_format))
        qf.add_volume(colorchange=True)
        qf.add_trendline(date0=downside_yield_date.strftime(time_format), date1=evaluation_date.strftime(time_format),
                         text=str(downside))  # add trend line
        # plyo.iplot(qf.iplot(asFigure=True))

        # make a radar plot
        vwap = data[&#39;VWAP&#39;].to_numpy()
        rsi = data[&#39;RSI&#39;].to_numpy()
        s_rsi = minmax_scale(rsi, feature_range=(0, 1))
        s_vwap = minmax_scale(vwap, feature_range=(0, 1))

        # reduce the array dimensionality/complexity
        s_vwap = self.reduce_array(arr=s_vwap, time_period=self.time_period)
        s_rsi = self.reduce_array(arr=s_rsi, time_period=self.time_period)
        variables = self.numba_interweave(s_vwap, s_rsi)  # interweave vwap and rsi
        data = np.array(variables)
        ranges = []
        for _ in range(0, len(variables)):
            ranges.append([0, 1])
        fig1 = plt.figure(figsize=(3, 3), dpi=150)
        radar = ComplexRadar(fig1, variables, ranges)
        radar.plot(data)
        radar.fill(data, alpha=0.2)

        plt.draw()
        plt.savefig(quant_title + &#34;_radar.png&#34;)
        # plt.show(block=False)
        time.sleep(0.10)
        fig1.clear()
        plt.close(fig1)

        pio.write_image(qf.iplot(asFigure=True),
                        file=quant_title + &#34;.png&#34;, width=2560, height=1707)
        qf.add_shapes()

        img = image.load_img(quant_title + &#34;_radar.png&#34;,
                             target_size=(300, 300))
        x = image.img_to_array(img)
        x = np.expand_dims(x, axis=0)
        images = np.vstack([x])
        classes = self.tf_model.predict(images, batch_size=10)

        if int(classes[0]) == 0:  # decoy
            # mv_file = &#34;mv &#34; + quant_title + &#34;* decoy/&#34;
            # os.system(mv_file)
            return [&#39;Decoy&#39;, self.ticker, downside, vwap_percent, todays_rsi]

        elif int(classes[0]) == 1:  # target
            # mv_file = &#34;mv &#34; + quant_title + &#34;* target/&#34;
            # os.system(mv_file)
            return [&#39;Target&#39;, self.ticker, downside, vwap_percent, todays_rsi]

        else:
            print(&#34;*******: Something is seriously wrong with the logic&#34;)

        return [&#39;Skip&#39;, &#39;Error&#39;]</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="bot.signal_generator.AutoPlotNsave.compute_rsi"><code class="name flex">
<span>def <span class="ident">compute_rsi</span></span>(<span>df, periods)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes Relative strength index for a given</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>data frame</code></dt>
<dd>contains time series</dd>
<dt><strong><code>periods</code></strong> :&ensp;<code>int</code></dt>
<dd>rolling window period, typically 14 days</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>df (data frame): the returned dataframe now contains computed 'RSI' column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def compute_rsi(df, periods):
    &#34;&#34;&#34;Computes Relative strength index for a given

    Args:
        df (data frame): contains time series
        periods (int): rolling window period, typically 14 days

    Returns:
        df (data frame): the returned dataframe now contains computed &#39;RSI&#39; column
    &#34;&#34;&#34;

    df[&#39;Up&#39;] = df[&#39;Close&#39;].diff().apply(lambda x: x if x &gt; 0 else 0)
    df[&#39;Down&#39;] = df[&#39;Close&#39;].diff().apply(lambda x: -x if x &lt; 0 else 0)
    df[&#39;UpAvg&#39;] = df[&#39;Up&#39;].rolling(window=periods).mean()
    df[&#39;DownAvg&#39;] = df[&#39;Down&#39;].rolling(window=periods).mean()
    df[&#39;RSI&#39;] = 100 - (100 / (1 + df[&#39;UpAvg&#39;] / df[&#39;DownAvg&#39;]))
    return df</code></pre>
</details>
</dd>
<dt id="bot.signal_generator.AutoPlotNsave.numba_interweave"><code class="name flex">
<span>def <span class="ident">numba_interweave</span></span>(<span>arr1, arr2)</span>
</code></dt>
<dd>
<div class="desc"><p>interweaves one array with another, eg [1,2,3] and [A, B, C] = [1, A, 2, B, 3, C]
:param arr1:
:param arr2:
:return: interweave array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def numba_interweave(arr1, arr2):
    &#34;&#34;&#34;
    interweaves one array with another, eg [1,2,3] and [A, B, C] = [1, A, 2, B, 3, C]
    :param arr1:
    :param arr2:
    :return: interweave array
    &#34;&#34;&#34;
    res = np.empty(arr1.size + arr2.size, dtype=arr1.dtype)
    for idx, (item1, item2) in enumerate(zip(arr1, arr2)):
        res[idx * 2] = item1
        res[idx * 2 + 1] = item2
    return res</code></pre>
</details>
</dd>
<dt id="bot.signal_generator.AutoPlotNsave.reduce_array"><code class="name flex">
<span>def <span class="ident">reduce_array</span></span>(<span>arr, time_period)</span>
</code></dt>
<dd>
<div class="desc"><p>Dimensonality or data reduction by averaging over a specified window of three.
:param arr:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def reduce_array(arr, time_period):
    &#34;&#34;&#34;
    Dimensonality or data reduction by averaging over a specified window of three.
    :param arr:
    :return:
    &#34;&#34;&#34;
    factor = int(time_period / 3.0)
    if len(arr) % (3 * factor) == 0:
        t = np.mean(arr.reshape(-1, (3 * factor)), axis=1)
    else:
        t = np.nanmean(
            np.pad(arr.astype(float), (0, (3 * factor) - arr.size % (3 * factor)), mode=&#39;constant&#39;,
                   constant_values=np.NaN).reshape(-1, 3 * factor), axis=1)

    return t</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="bot.signal_generator.AutoPlotNsave.cufflinks_display"><code class="name flex">
<span>def <span class="ident">cufflinks_display</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cufflinks_display(self):
    &#34;&#34;&#34;[summary]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    data = self.compute_rsi(self.time_series, periods=14)
    try:
        start = self.time_series.index[len(self.time_series.index) - (67 * int(self.time_period / 3.0))]
        stop = self.time_series.index[-1]
        evaluation_date = self.time_series.index[- 1]
    except Exception as e:
        print(e)
        return [&#39;Error&#39;, self.ticker, &#39;Could not get data&#39;]
    time_format = &#39;%d%b%y&#39;
    quant_title = self.ticker + &#34;_&#34; + start.strftime(time_format) + &#34;_&#34; + evaluation_date.strftime(time_format)

    data = data.loc[start:stop]
    data[&#39;VWAP&#39;] = (data[&#39;Volume&#39;] * (data[&#39;High&#39;] +
                                      data[&#39;Close&#39;]) / 2).cumsum() / data[&#39;Volume&#39;].cumsum()

    # is today&#39;s close price less than vwap ?
    vwap_percent = (data[&#39;Close&#39;].loc[stop] / data[&#39;VWAP&#39;].loc[stop] - 1) * 100

    todays_rsi = data[&#39;RSI&#39;].loc[stop]

    rsi_within_threshold = False

    for t_rsi in range(5, self.rsi_threshold):

        if todays_rsi &lt;= t_rsi:
            # print(&#34;Rsi is within threshold of &#34;, t_rsi, &#34;/&#34;, todays_rsi)
            rsi_within_threshold = True
            break

    if not rsi_within_threshold:
        # print(&#34;Rsi is Not within threshold of 5-&#34;, self.rsi_threshold, &#34;:&#34;, todays_rsi)
        return [&#39;Skip&#39;, self.ticker, vwap_percent, todays_rsi]

    # if the downtrend is not within a specified limit, continue

    daily_percent_change = (data[&#39;Close&#39;].loc[evaluation_date] / data[&#39;Close&#39;] - 1) * 100
    downside_yield_date = daily_percent_change.idxmin()
    downside = round(daily_percent_change.min(), 2)

    if not downside &lt;= self.down_threshold:
        return [&#39;Skip&#39;, self.ticker, downside, vwap_percent, todays_rsi]
    # plot candle chart
    quotes = data[[&#39;Open&#39;, &#39;High&#39;, &#39;Low&#39;, &#39;Close&#39;, &#39;Volume&#39;]]
    qf = cf.QuantFig(quotes, title=quant_title, name=&#39;1D Historical&#39;, up_color=&#39;green&#39;, down_color=&#39;red&#39;)
    qf.add_rsi(periods=14, showbands=True)
    qf.add_bollinger_bands()
    qf.add_support(date=evaluation_date.strftime(time_format))
    qf.add_volume(colorchange=True)
    qf.add_trendline(date0=downside_yield_date.strftime(time_format), date1=evaluation_date.strftime(time_format),
                     text=str(downside))  # add trend line
    # plyo.iplot(qf.iplot(asFigure=True))

    # make a radar plot
    vwap = data[&#39;VWAP&#39;].to_numpy()
    rsi = data[&#39;RSI&#39;].to_numpy()
    s_rsi = minmax_scale(rsi, feature_range=(0, 1))
    s_vwap = minmax_scale(vwap, feature_range=(0, 1))

    # reduce the array dimensionality/complexity
    s_vwap = self.reduce_array(arr=s_vwap, time_period=self.time_period)
    s_rsi = self.reduce_array(arr=s_rsi, time_period=self.time_period)
    variables = self.numba_interweave(s_vwap, s_rsi)  # interweave vwap and rsi
    data = np.array(variables)
    ranges = []
    for _ in range(0, len(variables)):
        ranges.append([0, 1])
    fig1 = plt.figure(figsize=(3, 3), dpi=150)
    radar = ComplexRadar(fig1, variables, ranges)
    radar.plot(data)
    radar.fill(data, alpha=0.2)

    plt.draw()
    plt.savefig(quant_title + &#34;_radar.png&#34;)
    # plt.show(block=False)
    time.sleep(0.10)
    fig1.clear()
    plt.close(fig1)

    pio.write_image(qf.iplot(asFigure=True),
                    file=quant_title + &#34;.png&#34;, width=2560, height=1707)
    qf.add_shapes()

    img = image.load_img(quant_title + &#34;_radar.png&#34;,
                         target_size=(300, 300))
    x = image.img_to_array(img)
    x = np.expand_dims(x, axis=0)
    images = np.vstack([x])
    classes = self.tf_model.predict(images, batch_size=10)

    if int(classes[0]) == 0:  # decoy
        # mv_file = &#34;mv &#34; + quant_title + &#34;* decoy/&#34;
        # os.system(mv_file)
        return [&#39;Decoy&#39;, self.ticker, downside, vwap_percent, todays_rsi]

    elif int(classes[0]) == 1:  # target
        # mv_file = &#34;mv &#34; + quant_title + &#34;* target/&#34;
        # os.system(mv_file)
        return [&#39;Target&#39;, self.ticker, downside, vwap_percent, todays_rsi]

    else:
        print(&#34;*******: Something is seriously wrong with the logic&#34;)

    return [&#39;Skip&#39;, &#39;Error&#39;]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bot" href="index.html">bot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="bot.signal_generator.AutoPlotNsave" href="#bot.signal_generator.AutoPlotNsave">AutoPlotNsave</a></code></h4>
<ul class="">
<li><code><a title="bot.signal_generator.AutoPlotNsave.compute_rsi" href="#bot.signal_generator.AutoPlotNsave.compute_rsi">compute_rsi</a></code></li>
<li><code><a title="bot.signal_generator.AutoPlotNsave.cufflinks_display" href="#bot.signal_generator.AutoPlotNsave.cufflinks_display">cufflinks_display</a></code></li>
<li><code><a title="bot.signal_generator.AutoPlotNsave.numba_interweave" href="#bot.signal_generator.AutoPlotNsave.numba_interweave">numba_interweave</a></code></li>
<li><code><a title="bot.signal_generator.AutoPlotNsave.reduce_array" href="#bot.signal_generator.AutoPlotNsave.reduce_array">reduce_array</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>